# 알고리즘, 그래프

## 목차

- [알고리즘이란](#알고리즘이란)
- [오일러 순환과 해밀턴 순환](#오일러-순환과-해밀턴-순환)

## 알고리즘이란

> 문제를 해결하기 위한 **절차를 기술**한 것<br/>누구나 **동일한 입력값**이 주어지면 이 절차대로 실행하면 동일한 출력값을 얻을 수 있어야 한다.

### 알고리즘 정의

- **순서대로 정의된 절차**
  - <u>분명한 순서</u>가 있어야 한다.
  - 한 동작을 실행하면 <u>다음에 실행할 동작이 무엇인지 분명</u>해야 한다
- **명확성**
  - 모든 동작은 <u>명확하게 정의</u>되어야 한다.<br/>
  - 모든 동작은 <u>실행 가능</u>해야 한다.
- **반드시 원하는 결과가 나와야 한다.**
- **일정한 시간 안에 실행되어야 한다.**

> 일상에서 유사한 알고리즘으로 **요리법**을 들 수 있겠지만 요리법은 알고리즘이라고 할 수 없다.<br/>왜냐하면 '먹기 좋은 크기', '중간 센 불'과 같이 **주관적인 언어**가 들어가 있기 때문에 모든 사람의 요리 결과가 하상 동일하지 않다.

### 알고리즘을 어떻게 적을까?

보통 아래 그림과 같이 사용하는 **일반 언어**로 적어 본다. <br/>그러나 읽거나 이해하기 힘들다! 알고리즘의 **구조적인 특성**이 드러나있지 않기 때문이다.<br/>말하고자 하는 바를 명확히 알려면 한줄 한줄 제대로 다 따라가면서 읽어야 한다..

![알고리즘작성](img/알고리즘작성.jpg)

### 좀더 알기쉽게 적을 수는 없을까?

> **구조를 살려서 표현**하면 읽는 사람 입장에서 이해하기 쉽다! ⇨ 4가지 구조!
>
> **모든 언어(Java, C, Python 등)는 아래의 4가지 구조를 제공**하며 이 외 다른 프로그래밍 절차는 존재하지 않는다.

1. **순차적 구조(sequential structure)** : **기본적인 구조**로 각 단계별 순서대로 진행한다.

   ![순차적구조](img/순차적구조.JPG)

2. **분기 구조(branch)** : 조건에 따라 분기가 나눠진다.

   ![분기구조](img/분기구조.JPG)

3. **반복 구조(repetition)** : 어떤 조건을 만족하면 어떠한 절차를 반복한다.

   ![반복구조](img/반복구조.JPG)

4. **점프 구조(jump)** : 순차적으로 수행하다 어느 절차로 이동한다.

   ![점프구조](img/점프구조.JPG)

### 알고리즘 작성하기

그렇다면 우리는 알고리즘의 구조를 반영하여 적는다면 이해하기 쉬울 것이다.

- **알고리즘 기술 방법**
  - 플로우차트(flowchart)
    - 복잡해지면 도표가 많아져서 보기가 힘들어진다.
  - 프로그램 언어의 코드
    - 이것은 특정 프로그램 언어의 <u>문법을 알아야 된다</u>.
    - 또 코드 수준으로 자세히 적을 필요는 없다.
  - **수도코드(Pseudocode)**
    - 프로그램 언어의 코드 전 단계로 프로그램 언어들이 사용하는 구조를 그대로 이용한다.

> 플로우차트는 조금만 복잡해져도 표현 한계에 봉착한다. **수도코드로 쉽게 작성**하자!

- [위](#알고리즘을-어떻게-적을까?)에서 적었던 알고리즘을 수도 코드로 적어보면 다음과 같다.

  ![수도코드](img/수도코드.jpg)

### 수도 코드 작성법

1. 기본적인 룰은 없다.

2. block을 **명확히 표시**해야 한다. (block이란 한 조건에 따라붙는 조건)

   **들여쓰기**, { }를 통해 표시해도 되고, begin과 end를 통해 표현해주는 사람도 있다.

```
예시) 이진 탐색(binary search)

 만약 리스트의 키 값이 정렬되어 있다면 순차 검색 보다 빠른 시간 안에 검색을 할 수 있다.
 	{1, 3, 4, 5, 10, 13, 15, 20, 23, 32}
 먼저 찾고자 하는 키 값을 리스트의 중간에 위치한 값, 13과 비교한다.
 만약 찾고자 하는 키 값이 13보다 작으면 이 값은 13보다 왼쪽에 위치하고 있으며, 13보다 크다면 13의 오른쪽에 위치하고 있다.
 따라서 다음 단계에서 13보다 왼쪽에 있는 값들, 혹은 오른쪽에 있는 값들을 갖고 같은 절차를 반복한다.
```

- 다음과 같이 기술한 것은 **"abstract하게 기술되었다.(덜 구체적으로 기술)"**라고 표현한다.

![이진탐색_수도코드](img/이진탐색_수도코드.JPG)

- 위의 것보다 **더 구체적으로 기술**한 것은 다음과 같다.

  ![이진탐색_수도코드_구체적](img/이진탐색_수도코드_구체적.JPG)

### 알고리즘 검증이란?

> 모든 입력값에 대해 맞게 동작하여 **해당 알고리즘이 맞다는 것을 증명**하는 것

- **귀납법을 통해 증명**하게 되는데 이는 **몇 가지 사례에 대해 옳음을 보여야 한다**는 말과 같다.
- **일반적인 값**의 경우에 대해서 옳다는 것을 증명하고, **특수한 입력값(boundary condition)**에 대해서도 옳다는 것을 증명해야 한다.
  - 특수한 입력값은 리스트에 존재하지 않는 40과 같은 input을 의미한다.

🔼[위로](#목차)

## 오일러 순환과 해밀턴 순환

> 쾨니스버그의 다리 문제처럼 그래프를 이용해서 문제를 단순화할 수 있다. 우리는 그래프를 통해 알고리즘을 만들 수 있다. 

### 그래프 정의

그래프 G는 다음의 두 가지 집합으로 구성되며 G = {V, E}로 표시한다. <br/>여기서 V는 **정점(vertex)**들의 집합이며, E는 정점들을 연결하는 **선(edge)**들의 집합이다.

![그래프](img/그래프.JPG)

그래프는 전혀 낯선 정의가 아니다. 

- 예) 한 줄로 그리기 문제<br/>다음의 그래프 중 한 정점에서 시작해서 연결선을 한 번만 지나면서 그래프를 다 그릴 수 있는 것은 어느 것인가?
  ![한줄로_그리기](img/한줄로_그리기.JPG)

### 오일러 경로

- **오일러 경로(Eulerian path)** : 그래프 G의 모든 연결선을 한번만 방문하는 경로

- **오일러 순환(Eulerian cycle 혹은 circuit)** : 시작점과 끝점이 동일한 오일러 경로
- **오일러 그래프** : 오일러 순환이 존재하는 그래프

- **차수(degree)**

  : 정점 u에 접합된 연결선의 수<br/>: 차수는 `deg(u)`와 같이 표기하기도 한다.

  예시) `deg(v1) = 3`, `deg(v2) = 5`, `deg(v3) = 3`, `deg(v4) = 5`

  ![차수](img/차수.JPG)

> **[참고] What is 시작점, 중간점, 끝점 ???**
>
> ![시작점_중간점_끝점](img/시작점_중간점_끝점.JPG)
>
> 1. 시작점
>
>    반드시 **홀수**<br/>나가는 연결선이 있는데 들어오는 연결선이 존재한다면 시작점이 아니다.<br/>시작점에서 나가질 못하기 때문이다.
>
> 2. 중간 정점
>
>    반드시 **짝수**<br/>들어왔다가 반드시 나가는 연결선까지 있어야 중간정점이 된다.<br/>더 이상의 연결선이 없으면 해당 자리에 계속 머무르게 되기 때문이다.
>
> 3. 끝점
>
>    반드시 **홀수**<br/>시작점과 같은 원리로 연결선이 홀수여야 한다.

### <정리> 오일러 경로를 갖기 위한 필요충분 조건

2개 이상의 정점을 갖는 루프가 없는 연결 그래프에서 **홀수 차수**(odd degree)를 갖는 정점이 **하나도 없거나 오직 두 개**(시작점, 끝점)만 존재해야 한다.

특히, 모든 정점이 **짝수 차수**를 가지면 **오일러 순환**이 존재하며, 이 그래프는 오일러 그래프이다.

- 예시1) b와 d에 연결된 정점은 홀수이므로 두 정점을 시작점과 끝점으로 하는 오일러 경로가 존재한다.

![오일러경로1](img/오일러경로1.JPG)

- 예시2) a와 c의 차수가 홀수이므로 이 둘이 시작점, 끝점이 된다.

![오일러경로1](img/오일러경로2.JPG)

- 예시3) 다음의 그래프는 오일러 경로를 갖고 있는가?

  오일러 경로가 존재하지 않는다.

  ![오일러경로3](img/오일러경로3.JPG)

### 오일러 경로의 알고리즘 복잡도

> 다항식의 복잡도를 이용해 쉽게 풀 수 있다.

![알고리즘_복잡도](img/알고리즘_복잡도.jpg)

### 해밀톤 경로

- **해밀톤 경로(Hamitonian path)** : 그래프 G에서 모든 정점을 정확히 **한 번만** 지나는 경로
- **해밀톤 순환(Hamitonian cycle 혹은 circuit)** : 시작점과 끝점이 같은 해밀톤 경로

![해밀톤_순환](img/해밀톤_순환.jpg)

> 오일러 순환 : '**선**'이 중요<br/>해밀톤 순환 : '**점**'이 중요

```
예)
해밀톤 순환은 1857년에 만들어진 lcosian 퀴즈 문제에서 비롯되었다.
이 퀴즈 문제는 12면체의 20개의 각 정점에 도시 이름을 적고, 어느 한 도시에서 출발하여
모서리를 따라서 다른 모든 19개의 도시를 방문하고 처음 출발했던 도시로 돌아오는 게임이다.
물론 각 도시는 단 한번만 방문할 수 있다.
```

![해밀톤_순환_유래](img/해밀톤_순환_유래.jpg)

### 해밀톤 순환을 찾는 알고리즘

> 유감스럽게도 해밀톤 순환을 찾는 알고리즘은 오일러 순환과는 다르게 **존재하지 않는다.**<br/>그러므로 우리는 해밀톤 순환을 찾기 위해 **모든 경우를 시도해 봐야 한다!**

- Exhaustive Search (전수 조사)
  - 즉, 모든 경우의 수에 대해 조사해봐야 한다.
- 탐색해야 되는 경로의 수
  - 트리의 leaf의 수
- Node의 수 : n

- 트리의 높이 : **n + 1**

- Leaf의 수 : **2ⁿ**

  > 즉, 시간복잡도 `O(2ⁿ)`

![해밀톤순환_찾기](img/해밀톤순환_찾기.JPG)
