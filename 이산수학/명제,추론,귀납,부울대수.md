# 명제, 추론, 귀납, 부울대수

## 목차

- [명제란?](#명제란?)
- [명제의 논리적 표현](#명제의-논리적-표현)

## 명제란?

- 참(true) 혹은 거짓(false)을 판명할 수 있는 **선언적 문장** (declarative statement)

  > ※ **선언적 문장**이란? `~은 ~이다.`

Q. 다음 문장 중 선언적 문장인 것은?

```
1. 어제 비가 내렸다.
2. 물은 100도에서 끓는다.
3. 1 + 2 = 4
4. 지금 시간이 몇 시에요?
5. 내일까지 레포트를 내세요.
6. x + 1 = 2
7. 내일 비가 온다.
```

- **1번, 2번, 3번**의 문장은 참 거짓을 판별할 수 있는 명제다. (선언적 문장)
- **4번, 5번**과 같은 의문문, 명령문은 선언적 문장이 아니다.
- **6번**의 경우 x값에 따라 참 거짓이 달라지기 때문에 명제가 아니다.
- **7번**의 경우 비가 올 수도 안 올수도 있기 때문에(애매함) 명제라고 하기 힘들다.


### 명제의 참 거짓은 어떻게 판별할 수 있는가?

- 사실 명제 : **관찰, 측정, 실험**에 의해 참 거짓을 판별
- 논리 명제 : **수학, 형식**에 의해 참 거짓을 판별

> 우리가 **컴퓨터에서 다루게** 되는 명제는 **논리 명제**

### 복합(합성)명제란?

- 복합/합성 명제(compund proposition) : **단순 명제의 조합(연결)으로 만들어지는 명제**
- 조합은 명제의 **부정, 곱, 합, 조건명제, 쌍조건 명제** 등의 ***연산자***로 인해 이루어진다.
  - 일종의 문장에서의 <u>접속사</u> 역할
  - [연산자의 종류와 의미 정리](이산수학_기초.md#2강-명제와-연산자)

- **복합 명제의 값**은 **동치 관계와 진리표를 활용**해서 구할 수 있다.
  - [동치와 진리표 의미 정리](이산수학_기초.md#3강-역-이-대우)

> **[참고] 필요 충분 조건** 
>
> - `p → q` 일 때, p와 q **둘 다 참**이면 **p는 q이기 위한 충분조건이고 q는 p이기 위한 필요조건**이라 한다.<br/>
>   또한 `p → q`임과 **동시에** `q → p`가 **성립**하면 **p는 q이기 위한 필요충분 조건**이라 하며 **p와 q는 동치**가 된다.
> - A와 B의 집합 관계가 A ⊃ B이면 A는 B이기 위한 필요조건, B는 A이기 위한 충분조건이다.

## 명제의 논리적 표현

- 명제표현 : 논리적 기호로 명제를 표현하는 것 

### 명제의 구성

- 명제는 **주어(subject)**와 **술어(predicate)**로 구성되어 있다.
  ```
  예)
  "3은 6보다 작다"
  
  주어: 3은
  술어: 6보다 작다
  ```

- 명제는 **변수를 포함한 함수**로서 표현할 수 있다.

  ```
  예)
  "x에 2를 더하면 3이다."
  
  위 문장을 변수를 포함한 함수로 표현하면 다음과 같다.
  p(x) : x+2=3
  
  이 문장의 T/F 여부는 x값에 의해 결정된다.
  ```

우리는 x의 값을 표현하기 위해 x의 값을 한정할 수 있어야 한다. 이것이 바로 **한정사**

### 한정사

- 명제 함수 **p(x)의 정의역**은 **한정사를 사용하여 표현**할 수 있다.

- 한정사에는 다음의 **2가지 종류**가 존재

  - **All (전체 한정)**

    - **x가 갖는 모든 값에 대해서 p(x)가 참인 명제**를 p(x)의 전체 한정이라 한다.
    - `∀x p(x)` : p(x)가 가질 수 있는 값은 **모든 x**의 값이라는 의미

    ```
    p(x) : x² + 2x + 1 ≥ 0,
    x의 정의 구역: 실수
    
    p(x)는 (x+1)² ≥ 0 로 정리할 수 있다.
    => 그러면 ∀x p(x)는 참이다.
    ```

    ```
    p(x) : x² + 2x + 1 > 0,
    x의 정의 구역: 실수
    => 그러면 ∀x p(x)는 거짓이다.
    (x=-1이면 p(x)는 거짓이기 때문이다.)
    ```

  - **Some (존재 한정)**

    - **x가 갖는 값 중에서** p(x)가 참이 되게 하는 x가 존재하는 명제를 p(x)의 존재 한정이라 한다.
    - `∃x p(x)` : p(x)가 가질 수 있는 값은 **일부 x**의 값이라는 의미

    ```
    p(x) : x² + 1 ≤ 1,
    x의 정의 구역: 실수
    
    => 그러면 ∃x p(x)는 참이다.
    (x=0일 때 p(x)가 참이 되기 때문이다.)
    ```

    ```
    p(x) : x² + 1 < 1,
    x의 정의 구역: 실수
    
    => 그러면 ∃x p(x)는 거짓이다.
    (p(x)가 참이 되는 x의 값이 x의 정의 구역에서는 존재하지 않는다.)
    ```

### 논리적 기호로 명제를 표현

> 명제 : `~은 ~이다.`

- **장점**
  - 명제의 의미가 명료해진다.
  - 명제가 접속사로 인해 **복합명제**가 되어 **진리값에 의해** 명백히 판단될 수 있다.

- **문장의 논리적 표현**

  - 주어진 문장을 **논리적 기호로 표현하는 것**은 <u>수학이나, 논리 프로그래밍, 인공 지능 등의 분야</u>에서 매우 중요하다.
  - 지금까지 설명한 **명제 함수, 한정사**는 **문장을 논리적 기호로 표현하는데 사용**될 수 있다.

  ```
  예제1)
  "이 클래스의 모든 학생은 C 언어 인증 시험을 통과하였다."
  
  함수 C(x) : 학생 x는 C언어 인증 시험을 통과하였다.
  x의 정의 구역 : 이 클래스의 학생들
  ```

  - 하나의 동일한 명제는 여러가지로 표현 가능하다. <br/>우리는 이미 두 명제의 값이 같으면 두 명제는 **동일 명제**임을 배웠다.

  ```
  예제2) 예제1의 문장은 다음과 같이 표현할 수 있다.
  
  "모든 사람 x에 대하여, 만일 x가 이 클래스의 학생이면 x는 C언어 인증 시험을 통과하였다."
  
  함수 S(x) : x가 이 클래스의 학생이다. 
  함수 C(x) : 학생 x는 C언어 인증 시험을 통과하였다.
  x의 정의 구역 : 이 클래스의 학생들
  
  => 조건 명제로 표현 가능. ∀x(S(x) → C(x))
  ```

  ```
  예제3) 위의 예제의 문장은 다음과 같은 함수로 정의하여 표현할 수 있다.
  
  함수 Q(x, y) : 사람 x가 y를 통과하였다.
  =>  ∀x(S(x) → Q(x, C언어 인증 시험))
  ```

  ```
  예제4) "이 클래스를 듣는 어떤 학생은 독일을 방문한 적이 있다."
  
  이 문장은 다음과 같이 다시 쓸 수 있다.
  
  "이 클래스에는 x라는 학생이 있는데, 그 x라는 학생은 독일을 방문한 적이 있다."
  
  함수 S(x) : x가 이 클래스의 학생이다.
  함수 D(x) : x는 독일을 방문한 적이 있다.
  x의 정의 구역 : 이 클래스의 학생들
  
  => ∃x(S(x) ∧ D(x))
  ```

### 한정사를 이용한 명제의 부정

- **부분 부정** 

  ```
  "모든 컴퓨터하고가 학생들은 이산 수학을 듣는다."
  
  이것을 한정사를 이용하여 표현하면,
   p(x): x는 이산 수학을 듣는다.
   x의 정의 구역: 모든 컴퓨터학과 학생들
  => ∀x p(x)
  ```

  ```
  이 문장의 (부분) 부정은 
   "컴퓨터학과 학생이면서 이산 수학을 듣지 않는 학생도 있다."
  => ￢(∀x p(x)) = ∃x (￢p(x))
  ```

- **완전 부정**

  ```
  "컴퓨터학과 학생들 중 이산 수학을 듣는 사람이 존재한다."
  
  p(x): x는 이산 수학을 듣는다.
  x의 정의 구역: 컴퓨터학과 학생들
  => ∃x p(x)
  ```

  ```
  이 문장의 (완전) 부정은,
   "모든 컴퓨터학과 학생은 이산 수학을 듣지 않는다."
  => ￢(∃x p(x)) = ∀x (￢p(x))
  ```

### 중첩 한정사

- 필요한 경우에는 한 명제에서 2개 이상의 한정사를 사용할 수 있다.

  예) `∀x ∃y (x+y=0)`

```
예제2) 덧셈에 있어서 결합 법칙은 다음과 같이 표현할 수 있다.
∀x ∀y ∀z (x+(y+z) = ((x+y)+z)
```

```
예제3) "모든 실수 x,y에 대해서 x가 양수이고 y가 음수이면, x와 y의 곱은 음수이다."

논리 기호로 이 명제를 표현하면,
∀x ∀y ((x > 0) ∧ (y < 0) → (xy < 0))
```

```
예제4) 논리식 ∀x (M(x) ∨ ∃y (M(y) ∧ F(x,y)))을 문장으로 표현하라.

M(x): x가 삼성G6 폰을 가지고 있다.
F(x,y): x와 y가 친구이다.
x의 정의 구역: A학교의 학생들
y의 정의 구역: B학교의 학생들

"A학교의 모든 학생들은 삼성G6폰을 가지고 있거나, A학교 모든 학생들의 친구인 B학교 학생 중에서 삼성G6폰을 가지고 있는 학생이 있다."
```

> 위와 같이 명제를 **일상언어로 표현**하게 되면 **정확한 의미가 전달되기 어렵지만**, **논리식으로 표현**하면 의미가 오해없이 전달된다.

## 연역법과 귀납법, 수학적 귀납법

### 추론이란?

- Reasoning, inference
- 참으로 **알고 있는 명제(전제)**로부터 **새로운 참인 명제(결론)**를 찾는 과정 
  - 전제(predicate) : 이미 True라고 알고 있는 명제
  - 결론(conclusion) : 새롭게 찾아내려고 하는 참인 명제
- **결론을 도출하는 추론의 과정이 과연 타당하냐가 중요!**

> 논리(logic) : 어떤 것이 올바른 초론이 되겠는가에 대한 규칙

### 추론의 방법

#### 연역법

- 형식 논리의 다음과 같은 명제의 틀에 기반을 두고 있다.

  ```
  If P, then Q
  P
  -------------
  ∴ Q
  
  => 만약 P(전제)가 True라면 Q(결론)도 True이다.
  ```

- 이것을 우리가 앞에서 배운대로 진리표로 표현하면 아래와 같다.

  | P → Q |  P   |  Q   |
  | :---: | :--: | :--: |
  |   T   |  T   |  T   |

- 연역법 추론의 예

  ```
  예1) 아리스토텔레스의 연역법
  
  All men is mortal. (모든 사람은 죽는다)
  Socrates is a man. (소크라테스는 사람이다)						 [전제]
  ---------------------------------------------------------------------
  Therefore, Socrates is mortal. (따라서 소크라테스는 죽는다)			[결론]
  ```

  ```
  예2)
  
  모든 컴퓨터공학과 학생들은 C언어를 수강한다.
  김철수는 컴퓨터공학과 학생이다.						[전제]
  -------------------------------------------------------
  그러므로 김철수는 C언어를 수강한다.					[결론]
  ```

  ```
  예3)
  
  모든 농구 선수들은 키가 크다.
  김철수는 농구 선수이다.				 [전제]
  -----------------------------------------
  그러므로 김철수는 키가 크다.			[결론]
  ```

  > 위 예제의 추론 방식이 올바른 추론일까??

- **연역법의 함정**

  - **과연 이 전제가 True인가?**

  - 만약 그렇지 않다면 연역의 논리를 따르고 있다고 하더라도 결론은 True가 될 수 없다.
  - 따라서 연역법에서는 전제가 과연 True냐가 키포인트!

- 수학

  - 수학의 이론은 **연역법에 의해** 만들어진 명제들로 이루어진다.
  - 수학은 공리 혹은 가정을 일단 True로 인정하는 것이 전제가 된다.
  - 혹은 이미 True라 증명된 정이에서부터 결론을 얻어낼 수 있다.

  ![수학과_연역법](../img/이산수학/수학과_연역법.JPG)

#### 귀납법

- **개별적인 사실**을 말하는 명제들로부터 일반적인 결론을 도출하는 방법

- 연역법과 추론의 방향이 다르다!

- 즉, 모든 원소에 대해서 True인 것을 보여주면 이 명제는 True다 라는 것을 보여줌.

  ```
  set, X = {x1, x2, x3, ... , Xn}
  명제 P(x, y) : x는 y이다.
  
  (모든 원소에 대해서 참인 경우)
  P(x1, y) is true
  P(x2, y) is true
  P(x3, y) is true
  ...
  P(Xn, y) is true
  
  ∴ ∀x p(x, y) is true. => 항상 True라고 인정하게 된다.
  ```

- 귀납법 예

  ```
  김철수, 이영희, 홍복동은 컴퓨터공학과 학생이다.
  김철수는 C언어를 수강하다
  이영희는 C언어를 수강하다
  홍복동는 C언어를 수강하다								[전제] - 모두 True
  ----------------------------------------------------------
  따라서 모든 컴퓨터공학과 학생들은 C언어를 수강한다.		 [결론]
  ```
  > "결론"은 모든 컴퓨터공학과 학생들의 집합에 대해 얘기하고 있는데,<br/> True로 밝혀진 "명제"들은 김철수, 이형희, 홍복동 제 사람에 대해서만 True임을 밝힌 것
  >
  > 따라서 **결론이 True라고 얘기할 수 없다.**

- 귀납법의 한계

  - 문제는 **현실적으로 집합의 모든 원소에 대해서** 참인 것을 **밝힐 수 없다**는 점

  - 따라서 도출된 결론은 기껏해야 **확률적인 결론일 수 밖에 없다.**

    `∀x p(x, y) is likely to be true.`

## 수학적 귀납법

- 우리가 증명하는데 굉장히 

